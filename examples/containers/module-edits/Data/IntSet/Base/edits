# These are TODOs:

# mutual recursion
skip Data.IntSet.Base.fromDistinctAscList
skip Data.IntSet.Base.fromAscList

# local termination via the bit mask
nonterminating Data.IntSet.Base.foldlBits
nonterminating Data.IntSet.Base.foldl'Bits
nonterminating Data.IntSet.Base.foldrBits
nonterminating Data.IntSet.Base.foldr'Bits

# Need to be implemented
rename value Data.Utils.BitUtil.shiftLL = Data.IntSet.Base.shiftLL
rename value Data.Utils.BitUtil.shiftRL = Data.IntSet.Base.shiftRL
rename value Data.Utils.BitUtil.highestBitMask = Data.IntSet.Base.highestBitMask

# partial
skip Data.IntSet.Base.findMax
skip Data.IntSet.Base.findMin
skip Data.IntSet.Base.maxView
skip Data.IntSet.Base.deleteMax
skip Data.IntSet.Base.deleteFindMax
skip Data.IntSet.Base.minView
skip Data.IntSet.Base.deleteMin
skip Data.IntSet.Base.deleteFindMin


# Avoid the natFromInt (and have a simpler implementation)
redefine Definition Data.IntSet.Base.mask : GHC.Num.Int -> (Mask -> Prefix) :=
  fun i m => Coq.ZArith.BinInt.Z.ldiff i (Coq.ZArith.BinInt.Z.ones (Coq.ZArith.BinInt.Z.succ (Coq.ZArith.BinInt.Z.log2 m))).

redefine Definition Data.IntSet.Base.zero : GHC.Num.Int -> (Mask -> bool) :=
  fun i m => Coq.ZArith.BinInt.Z.eqb (Coq.ZArith.BinInt.Z.land i m) 0.


# A bitmask adressing the last 6 bits of an int.
# This is the only place where otherwise the FiniteBits class is used
skip Data.IntSet.Base.suffixBitMask

# These are typical that they recurse left or right
termination Data.IntSet.Base.union        {measure ((size_nat arg_0__) + (size_nat arg_1__))} termination_by_omega
termination Data.IntSet.Base.difference   {measure ((size_nat arg_0__) + (size_nat arg_1__))} termination_by_omega
termination Data.IntSet.Base.intersection {measure ((size_nat arg_0__) + (size_nat arg_1__))} termination_by_omega

# Show stuff
skip Data.IntSet.Base.showsBars
skip Data.IntSet.Base.showsBitMap
skip Data.IntSet.Base.showBitMap
skip Data.IntSet.Base.showsTreeHang
skip Data.IntSet.Base.showTreeWith
skip Data.IntSet.Base.showBin
skip Data.IntSet.Base.showWide
skip Data.IntSet.Base.withBar
skip Data.IntSet.Base.withEmpty
skip Data.IntSet.Base.showsTree
skip Data.IntSet.Base.showTree

# Data stuff
skip Data.IntSet.Base.fromListConstr
skip Data.IntSet.Base.intSetDataType
skip Data.IntSet.Base.Monoid__IntSet


# We need Integral N to use GHC.Real.fromIntegral to go from N to Z
skip module Coq.ZArith.BinInt.Z
rename value Data.IntSet.Base.intFromNat = Coq.ZArith.BinInt.Z.of_N
skip Coq.ZArith.BinInt.Z.of_N
