# These are TODOs:

# mutual recursion
skip Data.IntSet.Base.fromDistinctAscList
skip Data.IntSet.Base.fromAscList

# local termination via the bit mask
nonterminating Data.IntSet.Base.foldlBits
nonterminating Data.IntSet.Base.foldl'Bits
nonterminating Data.IntSet.Base.foldrBits
nonterminating Data.IntSet.Base.foldr'Bits

# Need to be implemented
rename value Data.Utils.BitUtil.shiftLL = Data.IntSet.Base.shiftLL
rename value Data.Utils.BitUtil.shiftRL = Data.IntSet.Base.shiftRL
rename value Data.Utils.BitUtil.highestBitMask = Data.IntSet.Base.highestBitMask

# partial
skip Data.IntSet.Base.findMax
skip Data.IntSet.Base.findMin
skip Data.IntSet.Base.maxView
skip Data.IntSet.Base.deleteMax
skip Data.IntSet.Base.deleteFindMax
skip Data.IntSet.Base.minView
skip Data.IntSet.Base.deleteMin
skip Data.IntSet.Base.deleteFindMin

# The idiom `x .&. complement y` does not work at type `nat`, as the complement of
# a natural number is negative. But the expression [x `xor` (x .&. y)] is equivalent:
#
#	 quickCheck $ \x y -> (x .&. complement y) == (x `xor` (x.&.y))
#	 +++ OK, passed 100 tests.
#
# so we can use that:
rewrite forall x y, (x Data.Bits..&. (Data.Bits.complement y)) = (Data.Bits.xor x (x Data.Bits..&. y))

# Avoid the natFromInt
redefine Definition Data.IntSet.Base.mask : GHC.Num.Int -> (Mask -> Prefix) :=
  fun i m => Coq.ZArith.BinInt.Z.land i (Coq.ZArith.BinInt.Z.lxor (Coq.ZArith.BinInt.Z.lnot (Coq.ZArith.BinInt.Z.pred m)) m).
# Avoid the natFromInt
redefine Definition Data.IntSet.Base.zero : GHC.Num.Int -> (Mask -> bool) :=
  fun i m => Coq.ZArith.BinInt.Z.eqb (Coq.ZArith.BinInt.Z.land i m) 0.
# Avoid the natFromInt, and come up with a simpler definition
# (correctness checked by hand for small values).
redefine Definition Data.IntSet.Base.branchMask : Prefix -> (Prefix -> Mask) :=
  fun p1 p2 => Coq.ZArith.BinInt.Z.pow 2 (Coq.ZArith.BinInt.Z.log2 (Coq.ZArith.BinInt.Z.lxor p1 p2)).

# indexOfTheOnlyBit uses pointers and ugly stuff
redefine Definition Data.IntSet.Base.indexOfTheOnlyBit :=
 fun x => Coq.ZArith.BinInt.Z.of_N (Coq.NArith.BinNat.N.log2 x).

redefine Definition Data.IntSet.Base.lowestBitMask : Nat -> Nat :=
  fun n => Data.IntSet.Base.revNatSafe (Data.IntSet.Base.highestBitMask (Data.IntSet.Base.revNatSafe n)).

# the revNat function is only correct if its result is cropped to 64 bits.
add Data.IntSet.Base Definition Data.IntSet.Base.revNatSafe n := Coq.NArith.BinNat.N.modulo (Data.IntSet.Base.revNat n) (Coq.NArith.BinNat.N.pow 2 64).
# Use rewrite, not rename, to not change the name of the actual definition
rewrite forall, Data.IntSet.Base.revNat = Data.IntSet.Base.revNatSafe



# A bitmask adressing the last 6 bits of an int.
# This is the only place where otherwise the FiniteBits class is used
skip Data.IntSet.Base.suffixBitMask

# These are typical that they recurse left or right
termination Data.IntSet.Base.union        {measure ((size_nat arg_0__) + (size_nat arg_1__))} termination_by_omega
termination Data.IntSet.Base.difference   {measure ((size_nat arg_0__) + (size_nat arg_1__))} termination_by_omega
termination Data.IntSet.Base.intersection {measure ((size_nat arg_0__) + (size_nat arg_1__))} termination_by_omega

# Show stuff
skip Data.IntSet.Base.showsBars
skip Data.IntSet.Base.showsBitMap
skip Data.IntSet.Base.showBitMap
skip Data.IntSet.Base.showsTreeHang
skip Data.IntSet.Base.showTreeWith
skip Data.IntSet.Base.showBin
skip Data.IntSet.Base.showWide
skip Data.IntSet.Base.withBar
skip Data.IntSet.Base.withEmpty
skip Data.IntSet.Base.showsTree
skip Data.IntSet.Base.showTree

# Data stuff
skip Data.IntSet.Base.fromListConstr
skip Data.IntSet.Base.intSetDataType
skip Data.IntSet.Base.Monoid__IntSet


# We need Integral N to use GHC.Real.fromIntegral to go from N to Z
rename value Data.IntSet.Base.intFromNat = Coq.ZArith.BinInt.Z.of_N
skip Coq.ZArith.BinInt.Z.of_N

skip module Coq.ZArith.BinInt.Z
skip module Coq.NArith.BinNat.N
