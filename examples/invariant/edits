
# NOTE: This relies on support for parsing the let-tick construct.
# add invariant { module = Counter, qid = Counter.Counter, tyVars = [], constructor = MkC, useSigmaType = [zeroCounter, inc], invariant = Definition Counter.NonNegInv : (Counter.RawCounter -> Type) 
#     := fun x => let ' MkC_Raw n := x in ((n GHC.Base.>= (0%Z)) = true). }

promote Counter.valid


# So for now, we have:
add invariant { module = Counter, qid = Counter.Counter, tyVars = [], constructor = MkC, useSigmaType = [zeroCounter, inc], invariant = Definition Counter.NonNegInv : (Counter.RawCounter -> Type) 
    := fun x => valid x = true. }
# Note: `valid x = true` has type `Prop`


obligations Counter.zeroCounter admit
obligations Counter.inc admit
obligations Counter.dec admit
