

##############
### NEEDED for Exitify
# Id.asJoinId Id.idJoinArity Id.isJoinId Id.isJoinId_maybe
# Id.mkSysLocal Id.setIdOccInfo
#
# NEEDED for CoreFVs
# Id.idCoreRules Id.idSpecialisation Id.realIdUnfolding
# 
# NEEDED for CoreArity
# Id.idArity Id.idStateHackOneShotInfo Id.idStrictness Id.isJoinId
# Id.mkSysLocalOrCoVar Id.typeOneShot
##############

#
# we cannot verify these assertions as we aren't tracking whether types are
# coercion types are not. These two appear in Id.hs
#
rewrite forall , andb Util.debugIsOn (negb (negb (Core.isCoercionType ty))) = false
rewrite forall , andb Util.debugIsOn (negb (Core.isCoercionType ty)) = false

axiomatize definition Id.isStateHackType

# Type inference issue from HasDebugCallStack
in Id.isNeverLevPolyId rewrite forall , Core.idInfo = (@Core.idInfo tt)

redefine Definition Id.idCoreRules : Core.Id -> list (Core.CoreRule) 
   := fun x => nil.

axiomatize definition Id.zapFragileIdInfo
axiomatize definition Id.zapIdUsageEnvInfo

# Type/TyCoRep
axiomatize definition Id.isStrictId
axiomatize definition Id.isDictId
axiomatize definition Id.idRepArity
axiomatize definition Id.isEvVar	


# RepType
skip Id.idFunRepArity
skip Id.setCaseBndrEvald

# Needs `GHC.Prim.seq`, used to evaluate the type information strictly
# however, we are removing all type information so no need to do so.
# axiomatize definition Id.setIdType

in Id.setIdType rewrite forall x y,GHC.Prim.seq x y = y

# figure out GHC.Num.Int representation
#
axiomatize definition Id.mkTemplateLocal 
axiomatize definition Id.mkTemplateLocalsNum
axiomatize definition Id.mkTemplateLocals 
