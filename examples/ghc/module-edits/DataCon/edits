
# redefine Inductive DataCon.HsImplBang : Type := .
# redefine Inductive DataCon.EqSpec     : Type := .
# redefine Inductive DataCon.DataConRep : Type := .
# redefine Inductive DataCon.DataCon    : Type := .

# no Word8
skip Combined.dataConIdentity

# skipped fcns as a result of eliminating type information
# generally these fcns return units so are easy to replace

skip Combined.dataConRepArgTys
skip Combined.buildAlgTyCon
skip Combined.classDataCon
skip Combined.dataFieldType
skip Combined.dataConImplicitTyThings
skip Combined.dataConInstOrigArgTys
skip Combined.dataConOrigTyCon
skip Combined.dataConInstArgTys
skip Combined.splitDataProductType_maybe
skip Combined.dataConRepRepArity
skip Combined.specialPromotedDc
skip Combined.eqSpecPreds
skip Combined.dataConTheta


# still refer to TyCoRep
skip Combined.dataConExTyBinders
skip Combined.dataConExTyVars
# skip Combined.dataConFieldLabels
skip Combined.dataConFieldType
skip Combined.dataConOrigArgTys
skip Combined.dataConOrigResTy
skip Combined.dataConInstSig
skip Combined.dataConCannotMatch

skip Combined.buildSynTyCon
skip Combined.dataConRepStrictness
skip Combined.dataConSig
skip Combined.dataConUserType
skip Combined.eqHsBang

skip Combined.mkDataCon
skip Combined.isLegacyPromotableDataCon
skip Combined.isLegacyPromotableTyCon
skip Combined.dataConEqSpec
skip Combined.substEqSpec 


# uses enumFrom, coinductively
## Can locally add a length argument to freshNames, and then pass it in 
## in the call to mkCleanAnonTyConBinders
skip Combined.freshNames
skip Combined.mkCleanAnonTyConBinders

#
# Outputable.$$
rewrite forall x y, x Outputable.$$ y = x
rewrite forall x, Type.mkInvForAllTys x y = tt


