


axiomatize definition CoreUtils.needsCaseBinding
axiomatize definition CoreUtils.isDivOp
axiomatize definition CoreUtils.isExprLevPoly 
axiomatize definition CoreUtils.isExpandableApp
axiomatize definition CoreUtils.isCheapApp 
axiomatize definition CoreUtils.isEmptyTy
# needs Core.dataConCannotMatch
axiomatize definition CoreUtils.filterAlts

# termination issue (recursion through non-lambda value unsupported)
axiomatize definition CoreUtils.cheapEqExpr'

redefine Definition CoreUtils.tickHNFArgs : (Core.Tickish Core.Var) -> (Core.CoreExpr -> Core.CoreExpr) := 
  fun t orig => orig.

# refers to skipped components.
skip CoreUtils.collectMakeStaticArgs
skip CoreUtils.stripTicksTopT
skip CoreUtils.stripTicksTop
skip CoreUtils.mkTick
skip CoreUtils.mkTicks
skip CoreUtils.mkCast

in Core.mkAltExpr rewrite forall, Core.Type_ = (GHC.Err.default) 

# maybe axiomatize???
skip CoreUtils.isSaturatedConApp
skip CoreUtils.exprIsHNFlike
skip CoreUtils.exprIsHNF
skip CoreUtils.mkTixkNoHNF

axiomatize definition CoreUtils.exprIsConLike 
axiomatize definition CoreUtils.exprIsCheapX
axiomatize definition CoreUtils.exprIsBottom
axiomatize definition CoreUtils.exprIsDupable

#
# TODO: come back to this one
axiomatize definition CoreUtils.eqExpr

###############################################################################
## termination edits

termination CoreUtils.mergeAlts deferred


# Translating `cheapEqExpr'' failed: mutual recursion through non-lambda values unsupported 
 
in CoreUtils.eqExpr       inline mutual go_alt
in CoreUtils.exprIsCheapX inline mutual ok

in CoreUtils.eqExpr set type go_alt : Core.RnEnv2 -> (Core.CoreAlt -> (Core.CoreAlt -> bool))

# Justified by `NestedRecursionHelpers.all2Map_is_all2_map_map` plus changing
#
#     let '(xs,ys) := unzip xys in … ys …
#
# to
#
#     … (map snd xys) …
in CoreUtils.eqExpr rewrite forall p, Util.all2 p rs1 rs2 = NestedRecursionHelpers.all2Map p snd snd ps1 ps2

# Justified by `NestedRecursionHelpers.all2` plus `map id =1 id`.  Could also
# work with a better version of `Util.all2`; see issue #109.
in CoreUtils.eqExpr rewrite forall p, Util.all2 p a1 a2 = NestedRecursionHelpers.all2Map p id id a1 a2


in CoreUtils.diffUnfold termination go { measure arg_14__ } 
obligations CoreUtils.diffUnfold admit



############################################################
## skipped methods

# needs Platform.Plaform type
skip CoreUtils.rhsIsStatic

axiomatize definition CoreUtils.applyTypeToArgs
axiomatize definition CoreUtils.exprType
axiomatize definition CoreUtils.coreAltType
axiomatize definition CoreUtils.coreAltsType


## needs more from DataCon
axiomatize definition CoreUtils.dataConInstPat
axiomatize definition CoreUtils.dataConRepFSInstPat
axiomatize definition CoreUtils.dataConRepInstPat
axiomatize definition CoreUtils.refineDefaultAlt



in CoreUtils.stripTicksE inline mutual go_b
in CoreUtils.stripTicksE inline mutual go_a
in CoreUtils.stripTicksE set type      go_b : (b * Core.Expr b) -> (b * Core.Expr b)
in CoreUtils.stripTicksE set type      go_a : Core.Alt b        -> Core.Alt b

in CoreUtils.stripTicksT inline mutual go_b
in CoreUtils.stripTicksT inline mutual go_a
in CoreUtils.stripTicksT set type      go_b : (b * Core.Expr b) -> OrdList.OrdList (Core.Tickish Core.Id)
in CoreUtils.stripTicksT set type      go_a : Core.Alt b        -> OrdList.OrdList (Core.Tickish Core.Id)

axiomatize definition CoreUtils.diffUnfold
axiomatize definition CoreUtils.diffIdInfo
axiomatize definition CoreUtils.diffExpr
axiomatize definition CoreUtils.diffBinds


axiomatize definition CoreUtils.combineIdenticalAlts
axiomatize definition CoreUtils.tryEtaReduce

axiomatize definition CoreUtils.app_ok
axiomatize definition CoreUtils.expr_ok
axiomatize definition CoreUtils.exprOkForSideEffects
axiomatize definition CoreUtils.exprOkForSpeculation
axiomatize definition CoreUtils.bindNonRec
