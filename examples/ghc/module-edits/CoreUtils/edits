

redefine Definition CoreUtils.isDivOp : unit -> bool := GHC.Err.default.
redefine Definition CoreUtils.isExprLevPoly : Core.CoreExpr -> bool := GHC.Err.default.
redefine Definition CoreUtils.isExpandableApp : CheapAppFun := GHC.Err.default.
redefine Definition CoreUtils.isCheapApp : CheapAppFun := GHC.Err.default.
redefine Definition CoreUtils.cheapEqExpr' {b} : ((Core.Expr b) -> bool) -> (((Core.Expr b) -> ((Core.Expr b) -> bool))) := GHC.Err.default.


redefine Definition CoreUtils.isEmptyTy : unit -> bool := 
  fun x => false.
redefine Definition CoreUtils.mkCast : Core.CoreExpr -> (unit -> Core.CoreExpr) := 
  fun c t => c.
redefine Definition CoreUtils.mkTick : (Core.Tickish Core.Var) -> (Core.CoreExpr -> Core.CoreExpr) :=
  fun t orig => orig.
redefine Definition CoreUtils.tickHNFArgs : (Core.Tickish Core.Var) -> (Core.CoreExpr -> Core.CoreExpr) := 
  fun t orig => orig.

###############################################################################
## termination edits

termination CoreUtils.mergeAlts deferred


# Translating `cheapEqExpr'' failed: mutual recursion through non-lambda values unsupported 
 
in CoreUtils.eqExpr       inline mutual go_alt
in CoreUtils.exprIsCheapX inline mutual ok

in CoreUtils.eqExpr set type go_alt : Core.RnEnv2 -> (Core.CoreAlt -> (Core.CoreAlt -> bool))

# Justified by `NestedRecursionHelpers.all2Map_is_all2_map_map` plus changing
#
#     let '(xs,ys) := unzip xys in … ys …
#
# to
#
#     … (map snd xys) …
in CoreUtils.eqExpr rewrite forall p, Util.all2 p rs1 rs2 = NestedRecursionHelpers.all2Map p snd snd ps1 ps2

# Justified by `NestedRecursionHelpers.all2` plus `map id =1 id`.  Could also
# work with a better version of `Util.all2`; see issue #109.
in CoreUtils.eqExpr rewrite forall p, Util.all2 p a1 a2 = NestedRecursionHelpers.all2Map p id id a1 a2


in CoreUtils.diffUnfold termination go { measure arg_14__ } 
obligations CoreUtils.diffUnfold admit



############################################################
## skipped methods

skip CoreUtils.rhsIsStatic
skip CoreUtils.applyTypeToArgs
skip CoreUtils.exprType
skip CoreUtils.coreAltType
skip CoreUtils.coreAltsType


## needs more from DataCon
skip CoreUtils.dataConInstPat
skip CoreUtils.dataConRepFSInstPat
skip CoreUtils.dataConRepInstPat
skip CoreUtils.refineDefaultAlt


# needs Core.dataConCannotMatch
skip Core.filterAlts

in CoreUtils.stripTicksE inline mutual go_b
in CoreUtils.stripTicksE inline mutual go_a
in CoreUtils.stripTicksE set type      go_b : (b * Core.Expr b) -> (b * Core.Expr b)
in CoreUtils.stripTicksE set type      go_a : Core.Alt b        -> Core.Alt b

in CoreUtils.stripTicksT inline mutual go_b
in CoreUtils.stripTicksT inline mutual go_a
in CoreUtils.stripTicksT set type      go_b : (b * Core.Expr b) -> OrdList.OrdList (Core.Tickish Core.Id)
in CoreUtils.stripTicksT set type      go_a : Core.Alt b        -> OrdList.OrdList (Core.Tickish Core.Id)

skip CoreUtils.diffUnfold
skip CoreUtils.diffIdInfo
skip CoreUtils.diffExpr
skip CoreUtils.diffBinds


skip CoreUtils.combineIdenticalAlts
skip CoreUtils.tryEtaReduce

skip CoreUtils.app_ok
skip CoreUtils.expr_ok
skip CoreUtils.exprOkForSideEffects
skip CoreUtils.exprOkForSpeculation
skip CoreUtils.needsCaseBinding
skip CoreUtils.bindNonRec
