# 
# NEEDED by Exitify
# CoreFVs.CoreExprWithFVs CoreFVs.freeVars
# CoreFVs.freeVarsOf
#
# NEEDED from Id
# Id.idCoreRules Id.idSpecialisation Id.realIdUnfolding
#

# in CoreFVs.idRuleRhsVars rewrite forall get_fvs id, Core.mapUnionVarSet get_fvs (Id.idCoreRules id) = Core.emptyVarSet

# Make it easier for Coq to see termination
rename value Util.mapAndUnzip = NestedRecursionHelpers.mapAndUnzipFix 

#
# TODO: we don't try to translate the orphNames functions
# not quite there yet.
#
skip CoreFVs.orphNamesOfFamInst  # needs FamInstEnv
skip CoreFVs.orphNamesOfCoCon
skip CoreFVs.orphNamesOfCoAxBranch
skip CoreFVs.orphNamesOfType
skip CoreFVs.orphNamesOfProv
skip CoreFVs.orphNamesOfCoAxBranches
skip CoreFVs.orphNamesOfTypes
skip CoreFVs.orphNamesOfAxiom
skip CoreFVs.orphNamesOfCos
skip CoreFVs.orphNamesOfTyCon
skip CoreFVs.orphNamesOfCo

## TODO: nonstructural mutual recursion 
skip CoreFVs.exprOrphNames
skip CoreFVs.exprsOrphNames


in CoreFVs.exprOrphNames inline mutual go_alt

#
# These edits are due to the fact that Id's are missing information (Rules, Unfoldings and Types info)
# We assume that the missing information does not contain any free variables
#
# redefine Definition CoreFVs.idRuleFVs      : Core.Id  -> FV.FV := fun id  => FV.emptyFV.
# redefine Definition CoreFVs.varTypeTyCoFVs : Core.Var -> FV.FV := fun var => FV.emptyFV.
# redefine Definition CoreFVs.idUnfoldingFVs : Core.Id  -> FV.FV := fun id  => FV.emptyFV.


#
# expr_fvs
#
# This set of mutually-recursive functions is heavily edited to make it past Coq's 
# structural termination checker. (It is also no-longer mutually recursive).
#
# first, we get rid of parts of the structure that we do not need
#
skip CoreFVs.stableUnfoldingFVs
skip CoreFVs.stableUnfoldingVars
#
# Then we unfuse some recursive calls so that Coq can see that they are structural
#
in CoreFVs.expr_fvs rewrite forall bndr rhs, CoreFVs.rhs_fvs (pair bndr rhs) = FV.unionFV (CoreFVs.expr_fvs rhs) FV.emptyFV
in CoreFVs.expr_fvs rewrite forall alts,  (FV.mapUnionFV alt_fvs alts)  = FV.unionsFV (Lists.List.map alt_fvs alts)
in CoreFVs.expr_fvs rewrite forall pairs, (FV.mapUnionFV CoreFVs.rhs_fvs pairs) = FV.unionsFV (Lists.List.map (fun x => match x with | pair bndr rhs => CoreFVs.expr_fvs rhs end) pairs)
# Ignore ticks
in CoreFVs.expr_fvs rewrite forall t, CoreFVs.tickish_fvs t = FV.emptyFV


# This is a horrible hack.  The issue is:
#   1. `freeVars` is defined to simply be `go`, where `go` is a recursive
#      function.
#   2. `go`/`freeVars` is mutually recursive with `freeVarsBind`
#   3. We can't handle mutual recursion through non-lambda values, INCLUDING
#      through the `fix` resulting from inlining `go`.
# Thus:
#   A. We `collapse let` to get rid of `go`.
#   B. We change `go` into `CoreFVs.freeVars` to prevent `go` from being
#      preemptively recursive.
#   C. We have to rewrite the eta-expanded version or `hs-to-coq` sees
#   
#          Definition CoreFVs.freeVars := let go := … in CoreFVs.freeVars.
#      Which is (a) nonsensical, and (b) breaks `collapse let`.
collapse let CoreFVs.freeVars
in CoreFVs.freeVars rewrite forall x, go x = CoreFVs.freeVars x

# Justified by
#   ∙ In `let 'pair _ ys := GHC.List.unzip xys in …`, we know that
#     `ys = GHC.Base.map snd xys` (`Proofs.GHC.List.snd_unzip`).
#   ∙ Successive `map`s can be converted to one `map` plus function composition
#     (`Proofs.GHC.Base.map_map`).
in CoreFVs.freeVarsBind rewrite forall, GHC.Base.map CoreFVs.freeVars rhss = GHC.Base.map (CoreFVs.freeVars GHC.Base.∘ snd) binds
