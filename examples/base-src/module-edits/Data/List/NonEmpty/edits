# axiomatize module Data.List.NonEmpty
# poor treatment of <| and !! when axiomatized (notation, cannot rename them either)

rename value Data.List.NonEmpty.:| = NEcons

# still partial
skip Data.List.NonEmpty.!!

redefine Local Definition instance_GHC_Base_Applicative_Data_List_NonEmpty_op_zlztzg__ : forall {a} {b},
  (Data.List.NonEmpty (a -> b)) -> ((Data.List.NonEmpty a) -> (Data.List.NonEmpty b)) := fun {a} {b} => zipWith id.

order zipWith instance_GHC_Base_Applicative_Data_List_NonEmpty_op_zlztzg__ instance_GHC_Base_Applicative_Data_List_NonEmpty instance_GHC_Base_Monad_Data_List_NonEmpty_op_zgzg__ instance_GHC_Base_Monad_Data_List_NonEmpty_return_ instance_GHC_Base_Monad_Data_List_NonEmpty

order instance_forall___GHC_Base_Eq__a___GHC_Base_Eq___Data_List_NonEmpty_a_ instance_forall___GHC_Base_Ord_a___GHC_Base_Ord__Data_List_NonEmpty_a_

order instance_Data_Foldable_Foldable_Data_List_NonEmpty instance_Data_Traversable_Traversable_Data_List_NonEmpty reverse sort sortBy sortWith

# needs Data.OldList.transpose
skip Data.List.NonEmpty.transpose
# needs Data.OldList.intersperse
skip Data.List.NonEmpty.intersperse

skip Data.List.NonEmpty.iterate

skip Data.List.NonEmpty.inits

skip Data.List.NonEmpty.repeat

skip Data.List.NonEmpty.cycle

##???
skip Data.List.NonEmpty.unfoldr

# actually total, can't tell
skip Data.List.NonEmpty.scanr1
skip Data.List.NonEmpty.init
skip Data.List.NonEmpty.last
skip Data.List.NonEmpty.unfold

# recursive call to Foldable
skip Data.List.NonEmpty.groupBy
skip Data.List.NonEmpty.group
skip Data.List.NonEmpty.groupWith
skip Data.List.NonEmpty.groupAllWith
skip Data.List.NonEmpty.groupBy1
skip Data.List.NonEmpty.groupWith1
skip Data.List.NonEmpty.groupAllWith1
skip Data.List.NonEmpty.group1




redefine Local Definition instance_forall___GHC_Base_Eq__a___GHC_Base_Eq___NonEmpty_a__op_zsze__ {inst_a}
                                                                                        `{_: GHC.Base.Eq_ inst_a}
    : (NonEmpty inst_a) -> ((NonEmpty inst_a) -> bool) :=
  fun arg_198__ arg_199__ =>
    match arg_198__ , arg_199__ with
      | a , b => negb (instance_forall___GHC_Base_Eq__a___GHC_Base_Eq___NonEmpty_a__op_zeze__ a b)
    end.


redefine Local Definition instance_Data_Foldable_Foldable_NonEmpty_elem :
  forall {a},
  forall `{_ : GHC.Base.Eq_ a}, a -> ((NonEmpty a) -> bool) :=
  fun {a} `{_ : GHC.Base.Eq_ a} => Coq.Program.Basics.compose
   (fun p => Data.Foldable.hash_compose Data.Monoid.getAny (instance_Data_Foldable_Foldable_NonEmpty_foldMap (Data.Foldable.hash_compose Data.Monoid.Mk_Any p)))
   GHC.Base.op_zeze__.

order instance_Data_Foldable_Foldable_NonEmpty_foldMap instance_Data_Foldable_Foldable_NonEmpty_elem
