skip module GHC.Types

skip GHC.Base.String   # replace with Coq type
skip GHC.Base.Maybe    # replace with Coq type

skip GHC.Base.++       # replace with Coq

skip GHC.Base.Opaque   # can't handle existential
skip GHC.Base.build    # higher-rank type
skip GHC.Base.augment  # higher-rank type

# partial
skip GHC.Base.until

# can't handle overloaded ifthenelse
skip GHC.Base.ifThenElse

# no IO
skip GHC.Base.unIO
skip GHC.Base.thenIO
skip GHC.Base.returnIO
skip GHC.Base.bindIO
skip GHC.Base.instance_GHC_Base_Functor_GHC_Types_IO
skip GHC.Base.instance_GHC_Base_Applicative_GHC_Types_IO
skip GHC.Base.instance_GHC_Base_Alternative_GHC_Types_IO
skip GHC.Base.instance_GHC_Base_Monad_GHC_Types_IO
skip GHC.Base.instance_GHC_Base_MonadPlus_GHC_Types_IO
skip GHC.Base.instance_forall___GHC_Base_Monoid_a___GHC_Base_Monoid__GHC_Types_IO_a_

# no unboxed types
skip GHC.Base.unsafeChr
skip GHC.Base.ord

skip GHC.Base.shiftRL#
skip GHC.Base.shiftL#
skip GHC.Base.iShiftL#
skip GHC.Base.iShiftRA#
skip GHC.Base.iShiftRL#
skip GHC.Base.divModInt#

skip GHC.Base.remInt
skip GHC.Base.quotRemInt
skip GHC.Base.divModInt
skip GHC.Base.divInt
skip GHC.Base.minInt
skip GHC.Base.maxInt
skip GHC.Base.modInt
skip GHC.Base.quotInt
skip GHC.Base.getTag

skip GHC.Base.primIntToChar
skip GHC.Base.primCharToInt
skip GHC.Base.primUnicodeMaxChar

## Type class instance ordering

order GHC.Base.instance_GHC_Base_Functor__GHC_Prim_arrow_r_ GHC.Base.instance_GHC_Base_Applicative__GHC_Prim_arrow_a__op_ztzg__ GHC.Base.instance_GHC_Base_Applicative__GHC_Prim_arrow_a_ GHC.Base.instance_GHC_Base_Monad__GHC_Prim_arrow_r__return_ GHC.Base.instance_GHC_Base_Monad__GHC_Prim_arrow_r_ GHC.Base.instance_GHC_Base_Alternative__GHC_Prim_arrow_r_ GHC.Base.instance_GHC_Base_MonadPlus__GHC_Prim_arrow_r_

order GHC.Base.instance_GHC_Base_Functor_list GHC.Base.instance_GHC_Base_Applicative_list GHC.Base.instance_GHC_Base_Monad_list_return_ GHC.Base.instance_GHC_Base_Monad_list_op_zgzg__ GHC.Base.instance_GHC_Base_Monad_list

order GHC.Base.instance_GHC_Base_Functor_option GHC.Base.instance_GHC_Base_Applicative_option_op_zlztzg__ GHC.Base.instance_GHC_Base_Applicative_option GHC.Base.instance_GHC_Base_Monad_option_op_zgzg__ GHC.Base.instance_GHC_Base_Monad_option_return_ GHC.Base.instance_GHC_Base_Monad_option GHC.Base.instance_GHC_Base_Alternative_option GHC.Base.instance_GHC_Base_MonadPlus_option

order GHC.Base.instance_GHC_Base_Functor__GHC_Tuple_pair_type_a_ GHC.Base.instance_forall___GHC_Base_Monoid_a___GHC_Base_Applicative__GHC_Tuple_pair_type_a_ GHC.Base.instance_forall___GHC_Base_Monoid_a___GHC_Base_Monad__GHC_Tuple_pair_type_a__return_ GHC.Base.instance_forall___GHC_Base_Monoid_a___GHC_Base_Monad__GHC_Tuple_pair_type_a__op_zgzgze__ GHC.Base.instance_forall___GHC_Base_Monoid_a___GHC_Base_Monad__GHC_Tuple_pair_type_a__op_zgzg__

order GHC.Base.instance_GHC_Base_Functor__GHC_Tuple_pair_type_a_ GHC.Base.instance_forall___GHC_Base_Monoid_a___GHC_Base_Applicative__GHC_Tuple_pair_type_a__op_ztzg__

skip GHC.Base.instance_GHC_Base_Alternative_list
skip GHC.Base.instance_GHC_Base_MonadPlus_list
skip GHC.Base.instance_GHC_Base_Alternative_option
skip GHC.Base.instance_GHC_Base_MonadPlus_option

# Haskellâ€™s definition of passes the f around, which trips over the
# termination checker when a function does nested recursion through map
# If we have a local fix for just the argument, then things often work out
redefine Definition GHC.Base.map {A B :Type} (f : A -> B) xs := Coq.Lists.List.map f xs.

class kinds GHC.Base.MonadPlus (Type -> Type)
