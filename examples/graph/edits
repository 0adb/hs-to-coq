###### Graph ######

skip module GHC.Show
skip module Data.Data
skip module System.IO

#skip for now because Data.OldList.GroupBy is not translated
skip Data.Graph.Inductive.Graph.glabEdges
skip Data.Graph.Inductive.Graph.equal

#for now - these use partial functions/Data.OldList.GroupBy
skip Data.Graph.Inductive.Graph.OrdGr
skip class GHC.Base.Ord
skip class GHC.Base.Eq_

#from IntSet - for consistency and because the Nodes cannot be negative
redefine Definition Data.Graph.Inductive.Graph.Node := Coq.Numbers.BinNums.N.

#termination for ufold - TODO: make lawful and prove for real
termination Data.Graph.Inductive.Graph.ufold        {measure (BinInt.Z.abs_nat(noNodes g))}
obligations Data.Graph.Inductive.Graph.ufold        admit

#coq cannot infer all of the type arguments correctly
in Data.Graph.Inductive.Graph.lab rewrite forall, GHC.Base.fmap = (@GHC.Base.fmap option _ _ _)

#ignore show output in errors
rewrite forall s, (GHC.Show.show s) = (GHC.Base.hs_string__ String.EmptyString)

#need some Default constraints
set type Data.Graph.Inductive.Graph.insEdge : forall {gr} {b} {a} `{(DynGraph gr)} `{(Err.Default (Context a b))}, (LEdge b) -> ((gr a b) -> (gr a b))
set type Data.Graph.Inductive.Graph.insEdges : forall {gr} {b} {a} `{(DynGraph gr)} `{(Err.Default (Context a b))}, list (LEdge b) -> ((gr a b) -> (gr a b))
set type Data.Graph.Inductive.Graph.context: forall {gr} {a} {b} `{(Graph gr)} `{(Err.Default (Context a b))}, (gr a b) -> (Node -> (Context a b))
set type Data.Graph.Inductive.Graph.deg: forall {gr} {a} {b} `{(Graph gr)} `{(Err.Default (Context a b))}, (gr a b) -> (Node -> GHC.Num.Int)

#Coq gets confused about some polymorphic definitions
in Data.Graph.Inductive.Graph.hasNeighborAdj rewrite forall, Data.Foldable.elem = GHC.List.elem
in Data.Graph.Inductive.Graph.deg' rewrite forall, Data.Foldable.length = GHC.List.length
in Data.Graph.Inductive.Graph.outdeg' rewrite forall, Data.Foldable.length = GHC.List.length
in Data.Graph.Inductive.Graph.indeg' rewrite forall, Data.Foldable.length = GHC.List.length
in Data.Graph.Inductive.Graph.deg rewrite forall, Data.Foldable.length = GHC.List.length
in Data.Graph.Inductive.Graph.outdeg rewrite forall, Data.Foldable.length = GHC.List.length
in Data.Graph.Inductive.Graph.indeg rewrite forall, Data.Foldable.length = GHC.List.length

#ignore Show stuff
skip Data.Graph.Inductive.Graph.prettify
skip Data.Graph.Inductive.Graph.prettyPrint

#number incompatibility and this function is not used for anything anyway - maybe go back and fix later
skip Data.Graph.Inductive.Graph.newNodes

########### QUEUE ############

#does not terminate on empty queue
set type Data.Graph.Inductive.Internal.Queue.queueGet: forall {a} `{(Err.Default (a * Queue a))}, Queue a -> (a * Queue a)
termination Data.Graph.Inductive.Internal.Queue.queueGet  deferred

######## HEAP #######

skip module Text.Show
skip Data.Graph.Inductive.Internal.Heap.prettyHeap
skip Data.Graph.Inductive.Internal.Heap.printPrettyHeap

#needs default as well for some reason
set type Data.Graph.Inductive.Internal.Heap.splitMin: forall {a} {b} `{(GHC.Base.Ord a)} `{(Err.Default ((a * b) * (Heap a b)))}, (Heap a b) -> ((a * b) * (Heap a b))
set type Data.Graph.Inductive.Internal.Heap.findMin: forall {a} {b} `{(Err.Default (a * b))}, (Heap a b) -> (a * b)

#need to prove that toList terminates - we need a function for the size of a heap
add Data.Graph.Inductive.Internal.Heap Fixpoint Data.Graph.Inductive.Internal.Heap.size {a} {b} (h: Heap a b) :=
match h with
| Empty => 0
| Node _ _ l => 1 + List.fold_right plus 0 (List.map (fun x => Data.Graph.Inductive.Internal.Heap.size x) l)
end.
order Data.Graph.Inductive.Internal.Heap.size Data.Graph.Inductive.Internal.Heap.toList

#need several lemmas and tactics to prove termination:
add Data.Graph.Inductive.Internal.Heap Lemma merge_size {a} {b} `{(GHC.Base.Ord a)} (h1 h2: Heap a b) : (size (merge h1 h2) = Nat.add (size h1) (size h2)). 
Proof.
intros. generalize dependent h2. induction h1; intros; simpl.
  - destruct h2; reflexivity.
  - destruct h2; simpl. omega. destruct (_GHC.Base.<_ a0 a1 ) eqn : ?; simpl; omega.
 Qed.

 add Data.Graph.Inductive.Internal.Heap Lemma mergeAll_size {a} {b} `{(GHC.Base.Ord a)} (l: list (Heap a b)) :
  size (mergeAll l) = List.fold_right plus 0 (List.map (fun x => size x) l).
Proof.
  intros. induction l using (well_founded_induction
                       (wf_inverse_image _ nat _ (@length _)
                          PeanoNat.Nat.lt_wf_0)).
  destruct l.
  - reflexivity.
  - destruct l.
    + simpl. omega.
    + simpl. repeat(rewrite merge_size). rewrite plus_assoc. rewrite H1. reflexivity. simpl. omega.
Qed. 

add Data.Graph.Inductive.Internal.Heap Lemma deleteMin_size {a} {b} `{(GHC.Base.Ord a)} (h: Heap a b) :
  (h <> Empty) ->
  ((size (deleteMin h) + 1) = size h).
Proof.
  intros. unfold deleteMin. destruct h. contradiction. rewrite mergeAll_size.
  unfold size. simpl. omega.
Qed. 

#can't use ltac, so prove the result as a lemma and apply it
add Data.Graph.Inductive.Internal.Heap Lemma toList_termination {a} {b} `{(GHC.Base.Ord a)} (h: Heap a b):
  (Empty <> h) ->
  (size (deleteMin h) < size h).
Proof.
  intros. assert (A: h <> Empty) by auto; apply deleteMin_size in A; omega.
Qed.

order merge_size mergeAll_size deleteMin_size toList_termination Data.Graph.Inductive.Internal.Heap.toList  

termination Data.Graph.Inductive.Internal.Heap.toList        {measure (Data.Graph.Inductive.Internal.Heap.size arg_0__)}
obligations Data.Graph.Inductive.Internal.Heap.toList       (Tactics.program_simpl; apply toList_termination; auto)

#more defaut constrants 
set type Data.Graph.Inductive.Internal.Heap.toList: forall {a} {b} `{(GHC.Base.Ord a)} `{(Err.Default (a * b))}, (Heap a b) -> list (a * b)
set type Data.Graph.Inductive.Internal.Heap.heapsort: forall {a} `{(GHC.Base.Ord a)} `{(Err.Default (a * a))}, list a -> list a 


###### BFS #######
#avoid use of repeat by using replicate instead - this is safe because we are zipping the two lists, only need up to length l1 elements of l2
in Data.Graph.Inductive.Query.BFS.suci rewrite forall c i, GHC.List.zip (Data.Graph.Inductive.Graph.suc' c) (GHC.List.repeat i) = GHC.List.zip (Data.Graph.Inductive.Graph.suc' c) (GHC.List.replicate (GHC.List.length (Data.Graph.Inductive.Graph.suc' c)) i)

#termination arguments - TODO - require lawful graphs and prove
termination Data.Graph.Inductive.Query.BFS.leveln       {measure (BinInt.Z.abs_nat(Data.Graph.Inductive.Graph.noNodes arg_1__))}
obligations Data.Graph.Inductive.Query.BFS.leveln       admit

in Data.Graph.Inductive.Query.BFS.lbf rewrite forall q b v q' x x', (match (Data.Graph.Inductive.Internal.Queue.queueGet q) with | pair (Data.Graph.Inductive.Graph.LP (cons (pair v x) x' as p)) q' => b | _ => GHC.Err.patternFailure end) = (let p := (cons (pair v x) x') in b)


#in Data.Graph.Inductive.Query.BFS.lbf rewrite forall q b v q' x x', (match (Data.Graph.Inductive.Internal.Queue.queueGet q) with | (pair (Data.Graph.Inductive.Graph.LP (cons (pair v x) x' as p)) q') => b | _ => GHC.Err.patternFailure end) = (let p := (cons (pair v x) x') in b)

#in Data.Graph.Inductive.Query.BFS.lbf rewrite forall q b, (match Data.Graph.Inductive.Inernal.Queue.queueGet q with | _ => b) = test
# = (match Data.Graph.Inductive.Internal.Queue.queueGet q with | pair (Data.Graph.Inductive.Graph.LP (cons (pair v _) _ )) q' => let p := Data.Graph.Inductive.Graph.LP (cons (pair v _) _) in b)


#a b, a as b = let b := a in
#in Data.Graph.Inductive.Query.BFS.lbf rewrite forall v p q', (pair (Data.Graph.Inductive.Graph.LP (cons (pair v _) _ as p)) q' =>) = (pair (Data.Graph.Inductive.Graph.LP (cons (pair v x) y)) q' => let p := (cons (pair v x) y) in)
termination Data.Graph.Inductive.Query.BFS.lbf       {measure (BinInt.Z.abs_nat(Data.Graph.Inductive.Graph.noNodes g))}
obligations Data.Graph.Inductive.Query.BFS.lbf       admit
