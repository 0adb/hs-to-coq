skip module Data.Word
skip module Utility
skip module VirtualMemory

import module Utility
import module Program
import module GHC.Real
import module Monads

rename type Utility.MachineInt = Coq.ZArith.BinInt.Z
rename type GHC.Types.Int = Coq.ZArith.BinInt.Z
rename value GHC.Real.fromIntegral = id

skip Decode.Eq___InstructionI
skip Decode.Eq___InstructionM
skip Decode.Eq___InstructionM64
skip Decode.Eq___InstructionI64
skip Decode.Eq___InstructionCSR
skip Decode.Eq___Instruction

skip Decode.rd
skip Decode.rs1
skip Decode.rs2
skip Decode.oimm12
skip Decode.oimm20
skip Decode.imm12
skip Decode.imm20
skip Decode.jimm20
skip Decode.sbimm12
skip Decode.simm12
skip Decode.shamt5
skip Decode.shamt6
skip Decode.pred
skip Decode.succ
skip Decode.csr12
skip Decode.zimm
skip Decode.csrInstruction
skip Decode.i64Instruction
skip Decode.iInstruction
skip Decode.m64Instruction
skip Decode.mInstruction

rename value Data.Bits.shift      = Coq.ZArith.BinInt.Z.shiftl
rename value Data.Bits..|.        = Coq.ZArith.BinInt.Z.lor
rename value Data.Bits..&.        = Coq.ZArith.BinInt.Z.land
rename value Data.Bits.xor        = Coq.ZArith.BinInt.Z.lxor
rename value Data.Bits.testBit    = Coq.ZArith.BinInt.Z.testbit
rename value Data.Bits.complement = Coq.ZArith.BinInt.Z.lnot

rename value GHC.Base.when = Utility.when

rewrite forall x y, x GHC.Base.< y = x < y
rewrite forall x y, x GHC.Base.>= y = x >= y
rewrite forall x y, x GHC.Base./= y = x /= y
# rewrite forall x y, x GHC.Base.op_zgze__
# rewrite forall x y, x GHC.Base.op_zl__
# rewrite forall x y, x GHC.Base.op_zsze__
rewrite forall x y, x GHC.Num.- y = x - y
rewrite forall x y, x GHC.Num.+ y = x + y
# rewrite forall x y, x GHC.Num.op_zm__
# rewrite forall x y, x GHC.Num.op_zp__
rewrite forall x y, x GHC.Real.mod_ y = Utility.rem x y

rewrite forall, GHC.Err.error "ambiguous decoding result" = InvalidInstruction
rewrite forall, GHC.Err.error GHC.Base.$ "dispatch bug: " = Monads.Return tt
rewrite forall, GHC.Err.error "dispatch bug: " = Monads.Return tt

# implemented in the preamble.v
rename value Utility.bitSlice = Decode.bitSlice

rewrite forall x, GHC.Num.fromInteger x = x
rewrite forall x y, (x GHC.Real.^ y) = Coq.ZArith.BinInt.Z.pow x y

# A work-around (Z is used like a module, but cannot be Require Importâ€™ed)
skip module Coq.ZArith.BinInt.Z

# order Decode.Eq___InstructionI Decode.Eq___InstructionM Decode.Eq___InstructionI64 Decode.Eq___InstructionM64 Decode.Eq___InstructionCSR Decode.Eq___Instruction_op_zeze__

rewrite forall x y, x GHC.Base.>>= y = Monads.Bind x y
rewrite forall x y, x GHC.Base.>> y = Monads.Bind x (fun _ => y)

rename value VirtualMemory.translate = Program.translate
rename value VirtualMemory.Load = Program.Load
rename value VirtualMemory.Instr = Program.Instr
rename value VirtualMemory.Store = Program.Store
