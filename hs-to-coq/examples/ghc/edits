#####################################################################
# for Bag

skip module Outputable
skip module Util
skip module Data.Data
skip module Data.List
skip module Data.Traversable

# Needs Data.Traversable
skip mapBagM
skip mapAndUnzipBagM
skip mapAccumBagL
# Needs MonadUtil.mapAccumLM
skip mapAccumBagLM
# Needs Data.OldList.partition
skip partitionBag
# Needs Util.partitionWith
skip partitionBagWith
# Needs Util.isSingleton
skip isSingletonBag
# Needs Control.Monad.filterM
skip filterBagM

## these all work now
# skip mapBagM_
# skip lengthBag
# skip foldrBagM
# skip foldlBagM
# skip foldlBag
# skip flatMapBagPairM
# skip flatMapBagM
# skip elemBag
# skip anyBagM
# skip allBagM
# skip anyBag

# These are lies
# rename value Data.Foldable.foldr = Coq.Lists.List.fold_right
# skip instance_Data_Foldable_Foldable_Bag

skip instance_forall___Data_Data_Data_a___Data_Data_Data__Bag_a_
skip instance_forall____Outputable_Outputable_a____Outputable_Outputable__Bag_a_

####################################################################
# for MonadUtils
skip module Control.Monad.Fix
skip module Control.Monad.IO.Class

# partial
skip unlessM

# needs GHC.Base.when
# skip whenM

# needs traversable
skip concatMapM
skip mapMaybeM

skip liftIO1
skip liftIO2
skip liftIO3
skip liftIO4

# UNDEFINED EVARS
skip mapAccumLM
skip mapAndUnzip3M
skip mapAndUnzip4M
skip mapAndUnzip5M
skip zipWithAndUnzipM
